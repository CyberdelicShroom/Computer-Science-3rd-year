/**This file/class contains the process of sending a file
 * over the network by RBUDP, making use of datagram packets
 * for data transfer and unique sequence numbers for the datagram 
 * packets. The code generated by the Netbeans IDE which handles
 * the GUI is also present in this class. This class also contains
 * the code, that had to be manually implemented, which handles the 
 * operations that occur upon clicking the button on the GUI.
 * 
 * @author Keagan Selwyn Gill
 **/


import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketTimeoutException;
import java.nio.ByteBuffer;
import java.util.Vector;
import javax.swing.JFileChooser;

/**
 *
 * @author Keagan
 */
public class RBUDPSenderWindow extends javax.swing.JFrame {
    
    static String host;
    static int port;
    static Boolean flag = false;
    /**
     * Creates new form RBUDPSenderWindow
     */
    public RBUDPSenderWindow() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        hostAddressField = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        portField = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        progressBar = new javax.swing.JProgressBar();
        jLabel4 = new javax.swing.JLabel();
        chooseFileButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setFont(new java.awt.Font("Segoe UI", 1, 22)); // NOI18N
        jLabel1.setText("RBUDP Sender");

        jLabel2.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        jLabel2.setText("Enter host address:");

        jLabel3.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        jLabel3.setText("Enter Port:");

        jLabel4.setText("Transfer progress:");

        chooseFileButton.setText("Select File");
        chooseFileButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                chooseFileButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(jLabel4)
                .addGap(195, 195, 195))
            .addGroup(layout.createSequentialGroup()
                .addGap(118, 118, 118)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(48, 48, 48)
                        .addComponent(jLabel1))
                    .addComponent(progressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 250, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(hostAddressField, javax.swing.GroupLayout.PREFERRED_SIZE, 114, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addComponent(portField, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addGap(31, 31, 31)
                                .addComponent(jLabel3)))
                        .addGap(8, 8, 8)))
                .addContainerGap(118, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(chooseFileButton, javax.swing.GroupLayout.PREFERRED_SIZE, 90, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(197, 197, 197))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(17, 17, 17)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jLabel3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(portField)
                    .addComponent(hostAddressField, javax.swing.GroupLayout.DEFAULT_SIZE, 31, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 11, Short.MAX_VALUE)
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(progressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 17, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(chooseFileButton, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(14, 14, 14))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /** This method executes when the user clicks the select file button.
     *  It stores the input from the user given in the two input fields
     *  for the host address and port. It also sets a Boolean flag to 
     *  true to instruct the program to send another file.
     **/
    private void chooseFileButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_chooseFileButtonActionPerformed
        host = hostAddressField.getText();
        port = Integer.parseInt(portField.getText());
        flag = true;
    }//GEN-LAST:event_chooseFileButtonActionPerformed
    
    /** This method lets the user select a file and proceeds to perform the
     * necessary operations to transfer the file via RBUDP. It also updates
     * the progress bar on the GUI as a file is transferring. It also computes
     * the transfer time and throughput of the file transfer process.
     * @param hostName the host address of the recipient
     * @param port the port of the recipient
     **/
    public static void selectFileAndSend(String hostName, int port) throws IOException {
        System.out.println("Sending the file");

        // Create socket, set the address and open file chooser
        DatagramSocket socket = new DatagramSocket();
        InetAddress address = InetAddress.getByName(hostName);
        
        File file = null;
        String fileName;
        JFileChooser jfc = new JFileChooser(); // File browser to choose file
        jfc.setFileSelectionMode(JFileChooser.FILES_ONLY); // Only files can be chosen (not directories)
        if (jfc.isMultiSelectionEnabled()) { // Only one file at a time (no multiple selection)
            jfc.setMultiSelectionEnabled(false);
        }

        int r = jfc.showOpenDialog(null);
        if (r == JFileChooser.APPROVE_OPTION) { // If a file is chosen
            file = jfc.getSelectedFile();
            fileName = file.getName();
            byte[] fileNameBytes = fileName.getBytes();
            // File name packet
            DatagramPacket sendFilenamePacket = new DatagramPacket(fileNameBytes, fileNameBytes.length, address, port);
            // Sending the packet with the file name
            socket.send(sendFilenamePacket); 
            
            // Create a byte array to store the file stream.
            byte[] fileByteArray = convertFileToByteArray(file); 
            
            int fileSizeKB = (fileByteArray.length)/1024;
            ByteBuffer bb = ByteBuffer.allocate(4); 
            bb.putInt(fileSizeKB); 
            byte[] fileSizeBytes = bb.array();
            
            System.out.println("FILE SIZE = " + fileSizeKB + " KB");
            // File size packet
            DatagramPacket sendFilesizePacket = new DatagramPacket(fileSizeBytes, fileSizeBytes.length, address, port);
            // Sending the packet with the file size
            socket.send(sendFilesizePacket);

            // Start a timer to calculate throughput.
            StartTime timer = new StartTime(0);

            // Create flag to represent the last message and a sequence number.
            int sequenceNumber = 0;
            boolean lastMessageFlag = false;

            // Create flag to represent the last confirmed message and a 16-digit serial number.
            int ackSequenceNumber = 0;
            int lastAckedSequenceNumber = 0;
            boolean lastAcknowledgedFlag = false;

            // Create counter to count retransmissions and initialize window size
            int retransmissionCounter = 0;
            int windowSize = 128;

            // Use vector to store sent message.
            Vector <byte[]> sentMessageList = new Vector <byte[]>();

            // Initialize the progress bar of the GUI by setting its
            // initial value to 0, displaying the percentage text and
            // setting the maximum value of the bar to the file size
            progressBar.setValue(0);
            progressBar.setStringPainted(true);
            progressBar.setMaximum(fileSizeKB);
            
            for (int i=0; i < fileByteArray.length; i = i+1021 ) {

                // Increment serial number.
                sequenceNumber += 1;

                // Create new byte array storage message.
                byte[] message = new byte[1024];

                // The first and second bytes of message are set to the sequence number.
                message[0] = (byte)(sequenceNumber >> 8);
                message[1] = (byte)(sequenceNumber);

                // If the packet is the last packet, then lastMessageFlag will set to true
                // and store the value 1 in the third byte of the header.
                if ((i+1021) >= fileByteArray.length) {
                    lastMessageFlag = true;
                    message[2] = (byte)(1);
                } else { 
                    // if not the last message, then lastMessageFlag will set to false 
                    //and store the value 0 in the third byte of the header.（false）
                    lastMessageFlag = false;
                    message[2] = (byte)(0);
                }

                // file bytes array copied to message array
                if (!lastMessageFlag) {
                    for (int j=0; j != 1021; j++) {
                        message[j+3] = fileByteArray[i+j];
                    }
                }
                // If it is the last message
                else if (lastMessageFlag) { 
                    for (int j=0;  j < (fileByteArray.length - i); j++) {
                        message[j+3] = fileByteArray[i+j];
                    }
                }

                // Create datagram packet for message
                DatagramPacket sendPacket = new DatagramPacket(message, message.length, address, port);

                // Add message to sent message list
                sentMessageList.add(message);
                
                while (true) {
                    // If the next sequence number is outside the window
                    if ((sequenceNumber - windowSize) > lastAckedSequenceNumber) {

                        boolean ackRecievedCorrect = false;
                        boolean ackPacketReceived = false;

                        while (!ackRecievedCorrect) {
                            // Process ack
                            byte[] ack = new byte[2];
                            DatagramPacket ackpack = new DatagramPacket(ack, ack.length);

                            try {
                                socket.setSoTimeout(50);
                                socket.receive(ackpack);
                                ackSequenceNumber = ((ack[0] & 0xff) << 8) + (ack[1] & 0xff);
                                ackPacketReceived = true;
                            } catch (SocketTimeoutException e) {
                                ackPacketReceived = false;
                                //System.out.println("Socket timed out while waiting for an acknowledgement");
                                //e.printStackTrace();
                            }

                            if (ackPacketReceived) {
                                if (ackSequenceNumber >= (lastAckedSequenceNumber + 1)) {
                                    lastAckedSequenceNumber = ackSequenceNumber;
                                }
                                ackRecievedCorrect = true;
                                System.out.println("Ack recieved: Sequence Number = " + ackSequenceNumber);
                                break;  // If there is ack then interrupt, so that the next packet can be sent
                            } else { 
                                // Resend packet
                                System.out.println("Resending: Sequence Number = " + sequenceNumber);
                                // Resend packets after the last acknowledged packet and all packets after that (cumulative acknowledgments)
                                for (int y=0; y != (sequenceNumber - lastAckedSequenceNumber); y++) {
                                    byte[] resendMessage = new byte[1024];
                                    resendMessage = sentMessageList.get(y + lastAckedSequenceNumber);

                                    DatagramPacket resendPacket = new DatagramPacket(resendMessage, resendMessage.length, address, port);
                                    socket.send(resendPacket);
                                    retransmissionCounter += 1;
                                }
                            }
                        }
                    } else { 
                        // Other pipes are not full, break so we can send message
                        break;
                    }
                }

                // Send the packet
                socket.send(sendPacket);
                System.out.println("Sent: Sequence number = " + sequenceNumber + ", Flag = " + lastMessageFlag);
                // Update progress bar percentage
                progressBar.setValue(sequenceNumber);

                // Process ack
                while (true) {
                    boolean ackPacketReceived = false;
                    byte[] ack = new byte[2];
                    DatagramPacket ackpack = new DatagramPacket(ack, ack.length);

                    try {
                        socket.setSoTimeout(10);
                        socket.receive(ackpack);
                        ackSequenceNumber = ((ack[0] & 0xff) << 8) + (ack[1] & 0xff);
                        ackPacketReceived = true;
                    } catch (SocketTimeoutException e) {
                        //System.out.println("Socket timed out waiting for an ack");
                        ackPacketReceived = false;
                        //e.printStackTrace();
                        break;
                    }

                    // Update ack and move the window forward
                    if (ackPacketReceived) {
                        if (ackSequenceNumber >= (lastAckedSequenceNumber + 1)) {
                            lastAckedSequenceNumber = ackSequenceNumber;
                            System.out.println("Ack recieved: Sequence number = " + ackSequenceNumber);
                        }
                    }
                }
            }

            // Keep checking and resend, until we receive the final ack
            while (!lastAcknowledgedFlag) {

                boolean ackRecievedCorrect = false;
                boolean ackPacketReceived = false;

                while (!ackRecievedCorrect) {
                    // Check a single ack
                    byte[] ack = new byte[2];
                    DatagramPacket ackpack = new DatagramPacket(ack, ack.length);

                    try {
                        socket.setSoTimeout(50);
                        socket.receive(ackpack);
                        ackSequenceNumber = ((ack[0] & 0xff) << 8) + (ack[1] & 0xff);
                        ackPacketReceived = true;
                    } catch (SocketTimeoutException e) {
                        //System.out.println("Socket timed out waiting for an ack");
                        ackPacketReceived = false;
                        //e.printStackTrace();
                    }

                    // Check if it is the last packet
                    if (lastMessageFlag) {
                        lastAcknowledgedFlag = true;
                        break;
                    }   
                    // If confirmation is received, the next packet can be sent
                    if (ackPacketReceived) {        
                        System.out.println("Ack recieved: Sequence number = " + ackSequenceNumber);
                        if (ackSequenceNumber >= (lastAckedSequenceNumber + 1)) {
                            lastAckedSequenceNumber = ackSequenceNumber;
                        }
                        ackRecievedCorrect = true;
                        break; // If there is an acknowledgment, you can send the next packet
                    } else { 
                        // Resend packet
                        // Resend packets after the last acknowledged packet and all packets after that (cumulative acknowledgments)
                        for (int j=0; j != (sequenceNumber-lastAckedSequenceNumber); j++) {
                            byte[] resendMessage = new byte[1024];
                            resendMessage = sentMessageList.get(j + lastAckedSequenceNumber);
                            DatagramPacket resendPacket = new DatagramPacket(resendMessage, resendMessage.length, address, port);
                            socket.send(resendPacket);
                            System.out.println("Resending: Sequence Number = " + lastAckedSequenceNumber);

                            // Increment retransmission counter
                            retransmissionCounter += 1;
                        }
                    }
                }
            }

            socket.close();
            System.out.println("File " + fileName + " has been sent");

            // Calculate throughput
            int transferTime = timer.getTimeElapsed() / 1000;
            double throughput = (double) fileSizeKB / transferTime;
            System.out.println("File size: " + fileSizeKB + "KB, Transfer time: " + transferTime + " seconds. Throughput: " + throughput + "KBps");
            System.out.println("Number of retransmissions: " + retransmissionCounter);
            flag = false;
        }
    }
    
    /** This method converts a file's data into a byte array.
     * @param file the file to be converted to a byte array
     **/
    private static byte[] convertFileToByteArray(File file) {
        FileInputStream fis = null;
        // Creating a byte array using the length of the file
        // file.length returns long so we have to cast to int
        byte[] byteArray = new byte[(int) file.length()];
        try {
            
            fis = new FileInputStream(file);
            fis.read(byteArray);
            fis.close();

        } catch (IOException ioExp) {
            ioExp.printStackTrace();
        }
        return byteArray;
    }

    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(RBUDPSenderWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(RBUDPSenderWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(RBUDPSenderWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(RBUDPSenderWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new RBUDPSenderWindow().setVisible(true);
            }
        });
        
        // This loop listens for input from the user, i.e., when the
        // user clicks the select file button. The sleep method
        // in the Thread class is called to cause the current thread
        // to suspend execution for 100 milliseconds. This is because 
        // the while loop iterates so fast that the program cannot
        // receive the instruction to interrupt the loop in order to
        // execute the necessary procedures for file transfer.
        while(true){
            try {
                System.out.println("Listening for input...");
                Thread.sleep(100);
                if(flag == true) {
                    try {
                        selectFileAndSend(host, port);
                    } catch(IOException e) {
                        e.printStackTrace();
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            
        }
        
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton chooseFileButton;
    private javax.swing.JTextField hostAddressField;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JTextField portField;
    private static javax.swing.JProgressBar progressBar;
    // End of variables declaration//GEN-END:variables
}
