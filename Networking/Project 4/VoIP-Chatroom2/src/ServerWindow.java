/** 
 * This class provides a GUI for displaying connected users and 
 * user activity information.
 * It is responsible for establishing new connections, and
 * then creating and passing these on to the client connection
 * handler class (ClientConnectionHandler).
 * 
 * A new ClientConnectionHandler class is constructed for
 * every client that connects to the server. It handles all
 * the input from clients, including commands, and sends
 * out the necessary data to the desired clients.
 * 
 * @author Keagan Selwyn Gill
 */

import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Arrays;
import java.net.DatagramPacket;

/** 
 * @author Keagan
 */
public class ServerWindow extends javax.swing.JFrame implements Runnable {

    private static ServerSocket server = null;
    private static Socket client = null;
    private ArrayList<String> clients = new ArrayList<>();
    private static final int clientLimit = 10;
    private static final ClientConnectionHandler[] clientThreads = new ClientConnectionHandler[clientLimit];
    private static PrintStream output = null;
    private static DatagramSocket voiceSocket = null;
    static sendPacket packetSender = new sendPacket();

    /**
     * Creates new form ServerWindow
     */
    public void ServerWindow() {
        initComponents();
        setVisible(true);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        onlineUsersList = new javax.swing.JList<>();
        jScrollPane2 = new javax.swing.JScrollPane();
        userActivityTextArea = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setFont(new java.awt.Font("Arial", 1, 24)); // NOI18N
        jLabel1.setForeground(new java.awt.Color(0, 153, 255));
        jLabel1.setText("VoIP Chatroom");

        jLabel2.setFont(new java.awt.Font("Arial", 1, 24)); // NOI18N
        jLabel2.setForeground(new java.awt.Color(0, 204, 204));
        jLabel2.setText("Server");

        jLabel3.setFont(new java.awt.Font("Arial", 1, 12)); // NOI18N
        jLabel3.setText("Online Users:");

        onlineUsersList.setModel(new javax.swing.AbstractListModel<String>() {
            String[] strings = {};
            public int getSize() { return strings.length; }
            public String getElementAt(int i) { return strings[i]; }
        });
        jScrollPane1.setViewportView(onlineUsersList);

        userActivityTextArea.setColumns(20);
        userActivityTextArea.setRows(5);
        jScrollPane2.setViewportView(userActivityTextArea);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(jLabel1)
                .addGap(198, 198, 198))
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 145, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 414, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(252, 252, 252)
                                .addComponent(jLabel2))
                            .addGroup(layout.createSequentialGroup()
                                .addContainerGap()
                                .addComponent(jLabel3)))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(9, 9, 9)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 340, Short.MAX_VALUE))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ServerWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ServerWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ServerWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ServerWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        new Thread(new ServerWindow()).start();
    }

    @Override
    public void run() {
        ServerWindow();
        Server();
    }

    /** 
     * Creates a server socket for clients to connect to. Creates and array of
     * instances of each client that is connected. Makes sure the maximum
     * allowed number of clients is not exceeded.
     */
    public void Server() {
        int i;
        int port = 8000;
        DatagramSocket socket = null;

        // open ServerSocket and UDP Socket for voice notes
        try {
            voiceSocket = new DatagramSocket(8001);
            server = new ServerSocket(port);
            userActivityTextArea.append("Server Running!\n");
        } catch (IOException e) {
            System.err.println(e);
        }

        // create new socket for each new client that attempts to connect
        while (true) {
            try {
                client = server.accept();

                for (i = 0; i < clientLimit; i++) {
                    if (clientThreads[i] == null) {
                        InetAddress inet = client.getInetAddress();
                        clientThreads[i] = new ClientConnectionHandler(client, voiceSocket, inet);
                        clientThreads[i].start();
                        break;
                    }
                }

                // Message if too many clients have connected
                if (i == clientLimit) {
                    output = new PrintStream(client.getOutputStream());
                    output.println("Chatroom full!");
                    userActivityTextArea.append("Client rejected due to client limit.\n");
                    output.close();
                    client.close();
                }

            } catch (IOException e) {
                System.err.println(e);
            }
        }
    }

    /** 
     * This is the broadcast method. Allows the server (and other clients) to
     * send messages to all currently connected clients.
     *
     * @param message string to broadcast to all clients.
     */
    public void bCast(String message) {
        for (ClientConnectionHandler ch : clientThreads) {
            if (ch != null) {
                ch.sendMessage(message);
            }
        }
    }

    /** 
     * This is the whisper method. It sends a private message to a specified
     * user.
     *
     * @param whisper message string to send.
     * @param recipient the recipient user of the whisper message.
     * @param sender the user who sent the whisper message.
     */
    public void whisper(String whisper, String recipient, String sender) {
        for (ClientConnectionHandler ch : clientThreads) {
            if (ch.username.equals(recipient)) {
                ch.whisperMessage(whisper, sender);
            }
            if (ch.username.equals(sender)) {
                ch.whisperMessage(whisper, sender);
            }
        }
    }

    /** 
     * This method creates a group with a set of clients, sends the 
     * group members as a string separated by a '-' delimiter to all
     * the clients in the group, and sets their inGroup flag to true.
     * @param groupMembers an array containing the clients joining a group
     */
    public void makeGroup(String[] groupMembers) {
        for(String member : groupMembers){
            for (ClientConnectionHandler ch : clientThreads) {
                if (ch != null){
                    if(ch.username.equals(member)){
                        String group = String.join("-", groupMembers);
                        ch.sendGroup(group);
                        ch.inGroup = true;
                    }
                }
            }
        }
    }
    
    /** 
     * This method sends the message that a user in a group sent to all the
     * other group members.
     * @param msg the message string
     * @param groupMembers an array containing the users in the group
     * @param sender the user sending the message
     */
    public void messageGroup(String msg, String[] groupMembers, String sender) {
        for(String member : groupMembers){
            for (ClientConnectionHandler ch : clientThreads) {
                if (ch != null){
                    if(ch.username.equals(member)){
                        ch.sendGroupMsg(sender + ": " + msg);
                    }
                }
            }
        }
    }
    
    /** 
     * This method sends the voice note audio data that a user in a group 
     * sent to all the other group members.
     * @param groupArray an array containing the users in the group
     * @param sender the user sending the voice note
     * @param vnByteArray the byte array containing the voice note audio data
     */
    public void sendGroupVN(String[] groupArray, String sender, byte[] vnByteArray) {
        for(String member : groupArray){
            for (ClientConnectionHandler ch : clientThreads) {
                if (ch != null){
                    if(ch.username.equals(member) && !member.equals(sender)){
                        System.out.println("VN SENT TO: [host: "+ch.inet.getHostName()+", member: "+member+", UDP port: "+ch.udpPort+"]");
                        packetSender.sendVN(ch.inet.getHostName(), vnByteArray, ch.udpPort);
                    }
                }
            }
        }
    }
    
    /** 
     * This method sends a signal to all the clients in the senders group
     * to listen for the incoming voice note data.
     * @param groupArray an array containing the users in the group
     * @param sender the user sending the voice note
     */
    public void sendVNListenSignal(String[] groupArray, String sender) {
        for(String member : groupArray){
            for (ClientConnectionHandler ch : clientThreads) {
                if (ch != null){
                    if(ch.username.equals(member) && !member.equals(sender)){
                        System.out.println("Listen signal sent to member: "+member);
                        ch.sendSignal("*listenVn:"+sender);
                    }
                }
            }
        }
    }
    
    /** 
     * This method sends a signal to all users to update their stored string
     * value of a user's username who has changed their username.
     * @param clientsArray an array containing the all the clients
     * @param originalName the original name of the user
     * @param newName the new name chosen by the user
     */
    public void updateUsername(String[] clientsArray, String originalName, String newName) {
        String clientsJoined = String.join("-", clientsArray);
        for (ClientConnectionHandler ch : clientThreads) {
                if (ch != null){
                    ch.changeUsername("$updateUsername:"+originalName+":"+newName+":"+clientsJoined);
                }
            }
    }
    
    /** 
     * This method sends a signal to all the selected group members to start
     * a group call.
     * @param groupMembers an array containing the users in the group
     * @param initiator the user who initiated the group call
     */
    public void sendCallListenSignal(String[] groupMembers, String initiator) {
        for(String member : groupMembers){
            for (ClientConnectionHandler ch : clientThreads) {
                if (ch != null){
                    if(ch.username.equals(member)){
                        ch.sendSignal("#listenCall:"+initiator);
                    }
                }
            }
        }
    }

    /** 
     * This method sends a signal to all the selected group members to 
     * indicate to them that a user has left the group call.
     * @param groupMembers an array containing the users in the group
     * @param user the user who disconnected from the group call
     */
    public void sendUserLeftCallMsg(String[] groupMembers, String user) {
        for(String member : groupMembers){
            for (ClientConnectionHandler ch : clientThreads) {
                if (ch != null){
                    if(ch.username.equals(member)){
                        ch.sendSignal("#callEnd:"+user);
                    }
                }
            }
        }
    }

    class ClientConnectionHandler extends Thread {

        private Socket client;
        private DataInputStream in;
        private DataOutputStream out;
        private String username;
        String[] clientsArray;
        String[] groupMembers;
        Boolean inGroup = false;
        InetAddress inet;
        ByteArrayOutputStream receivedVN;
        DatagramSocket voiceSocket;
        int udpPort;
        Boolean onCall = false;

        public ClientConnectionHandler(Socket client, DatagramSocket voiceSocket, InetAddress inet) {
            this.client = client;
            this.inet = inet;
            this.voiceSocket = voiceSocket;
        }

        /** 
         * This method requests a unique username from the client until the
         * client sends a unique username.
         *
         * @param username username that the client chose.
         * @param in the data input stream of the client.
         * @return the unique username.
         *
         */
        public String requestUniqueName(String username, DataInputStream in) {
            try {
                while (clients.contains(username)) {
                    out.writeUTF("That username is already in use, try entering another\nby typing it in the message box and sending it: ");
                    username = in.readUTF();
                }
            } catch (IOException e) {

            }
            return username;
        }
        
        /**
         * This method writes out a signal with a message to tell the user that
         * the username they chose is not unique and to try again with a unique
         * username
         */
        public void sendNonUniqueNameMsg() {
            try {
                out.writeUTF("nameNotUnique:That username is already in use.\nTry the command again with a unique username. ");
            } catch (IOException e) {

            }
        }


        /** 
         * This method sends out strings of all the currently connected clients
         * to the client that called the method and prints them out to the
         * terminal of the server.
         */
        public void printConnectedUsers() {
            System.out.println("\nConnected users:");
            try {
                out.writeUTF("\nConnected users:");
                for (String username : clients) {
                    System.out.println(username);
                    out.writeUTF(username);
                }
                System.out.println();

                out.writeUTF("");
            } catch (IOException e) {

            }
        }
        
        @Override
        public void run() {
            try {
                out = new DataOutputStream(client.getOutputStream());
                in = new DataInputStream(client.getInputStream());
                username = in.readUTF();
                udpPort = in.readInt();
                InetAddress Inet = client.getInetAddress();

                if (username != null) {
                    if (clients.contains(username)) {
                        username = requestUniqueName(username, in);
                        clients.add(username);
                    } else {
                        clients.add(username);
                    }
                    System.out.println(username + " has connected.");
                    clientsArray = new String[clients.size()];

                    for (int i = 0; i < clients.size(); i++) {
                        clientsArray[i] = clients.get(i);
                    }
                    Timestamp Tstamp = new Timestamp(System.currentTimeMillis());
                    userActivityTextArea.append(username + " joined with host name: " + Inet.getHostName() + "\nTimestamp: " + Tstamp + "\n\n");
                    Arrays.sort(clientsArray);
                    onlineUsersList.setListData(clientsArray);
                    bCast(username + " has connected.");
                    String clientsJoined = String.join("-", clientsArray);
                    bCast("clientsJoined:" + clientsJoined);

                    String message;

                    while ((message = in.readUTF()) != null) {
                        if (message.startsWith("/name ")) {
                            // Handle changing of username
                            String[] messageSplit = message.split(" ", 2);
                            String originalName = username;

                            if (!messageSplit[1].equals("") && !messageSplit[1].equals(" ")) {
                                if (clients.contains(messageSplit[1])) {
                                    sendNonUniqueNameMsg();
                                } else {
                                    username = messageSplit[1];
                                    clients.add(username);
                                    int index = clients.indexOf(originalName);
                                    clients.remove(index);
                                
                                    clientsArray = new String[clients.size()];
                                    for (int i = 0; i < clients.size(); i++) {
                                        clientsArray[i] = clients.get(i);
                                    }
                                    Arrays.sort(clientsArray);
                                    onlineUsersList.setListData(clientsArray);
                                    updateUsername(clientsArray, originalName, username);
                                    bCast(originalName + " renamed themself to " + username);
                                    System.out.println(originalName + " renamed themself to " + username);
                                    userActivityTextArea.append(originalName + " renamed themself to " + username+"\n");
                                }
                            } else {
                                out.writeUTF("No username provided. Try the command again with a unique username.");
                            }
                        } else if (message.startsWith("/quit")) {
                            // Handle user disconnection
                            int index = clients.indexOf(username);
                            clients.remove(index);
                            System.out.println(username + " has disconnected.");
                            bCast(username + " has disconnected.");
                            bCast("EXIT:" + username);
                            
                            if (!clients.isEmpty()) {
                                clientsArray = new String[clients.size()];
                                for (int i = 0; i < clients.size(); i++) {
                                    clientsArray[i] = clients.get(i);
                                }
                                Arrays.sort(clientsArray);
                                onlineUsersList.setListData(clientsArray);
                            } else {
                                String[] none = new String[]{""};
                                onlineUsersList.setListData(none);
                            }
                            userActivityTextArea.append(username + " has disconnected.\n");
                            shutdown();
                        } else if (message.startsWith("/users")) {
                            // prints all connected clients
                            printConnectedUsers();
                        } else if (message.startsWith("/whisper ")) {
                            // Handles the whisper command to send private
                            // messages.
                            String[] messageSplit = message.split(" ", 3);
                            String whisper = messageSplit[2];
                            String recipient = messageSplit[1];
                            if (clients.contains(recipient)) {
                                whisper(whisper, recipient, username);
                            } else {
                                out.writeUTF("'" + recipient + "'" + " does not exist in this chat room.");
                                printConnectedUsers();
                            }
                        } else if (message.startsWith("/group ")) {
                            // Handles the creation of a group
                            groupMembers = message.split("-");
                            groupMembers[0] = groupMembers[0].replace("/group ", "");
                            userActivityTextArea.append("Group made!\nGroup members:\n");
                            for (String member : groupMembers){
                                userActivityTextArea.append(member+"\n");
                            }
                            makeGroup(groupMembers);
                        } else if (message.startsWith("/groupMsg ")) {
                            // Handles sending a message to group members
                            String[] messageSplit = message.split(" ", 3);
                            String[] groupArray = messageSplit[1].split("-");
                            String msg = messageSplit[2];
                            messageGroup(msg, groupArray, username);
                        } else if (message.startsWith("/voicenote ")) {
                            // Handles the receiving of voice note and
                            // transferring it to the desired group members
                            int bufferSize = 65000;
                            receivedVN = new ByteArrayOutputStream();
                            byte[] buffer = new byte[bufferSize];
                            DatagramPacket p = new DatagramPacket(buffer, bufferSize);
                            voiceSocket.receive(p);
                            System.out.println("VN packet start");
                            if (buffer[0] == "*".getBytes()[0]) {
                                while(true){
                                    buffer = new byte[bufferSize];
                                    p = new DatagramPacket(buffer, bufferSize);
                                    voiceSocket.receive(p);
                                    if (buffer[0] == "*".getBytes()[0]) {
                                        System.out.println("voice note received.");
                                        receivedVN.close();
                                        break;
                                    } else {
                                        receivedVN.write(buffer, 0, buffer.length);
                                        System.out.println("Loading");
                                    }
                                }
                            }
                            String[] messageSplit = message.split(" ", 2);
                            String[] groupArray;
                            if(!messageSplit[1].contains("-")){
                                groupArray = new String[1];
                                groupArray[0] = messageSplit[1];
                            } else {
                                groupArray = messageSplit[1].split("-");
                            }
                            sendVNListenSignal(groupArray, username);
                            sendGroupVN(groupArray, username, receivedVN.toByteArray());
                            System.out.println("Voice note sent.");
                        } else if (message.startsWith("/call:")) {
                            // Sends a signal to the desired group members
                            // to start group call
                            String[] messageSplit = message.split(":");
                            String[] groupArray;
                            if(!messageSplit[1].contains("-")){
                                groupArray = new String[1];
                                groupArray[0] = messageSplit[1];
                            } else {
                                groupArray = messageSplit[1].split("-");
                            }
                            String initiator = messageSplit[2];
                            sendCallListenSignal(groupArray, initiator);
                        } else if (message.startsWith("/callEnd:")) {
                            // Sends a message to all the desired group
                            // members indicating that a user has left
                            // the group call
                            String[] messageSplit = message.split(":");
                            String[] groupArray;
                            if(!messageSplit[1].contains("-")){
                                groupArray = new String[1];
                                groupArray[0] = messageSplit[1];
                            } else {
                                groupArray = messageSplit[1].split("-");
                            }
                            String user = messageSplit[2];
                            sendUserLeftCallMsg(groupArray, user);
                        } else {
                            bCast(username + ": " + message);
                        }
                    }
                }
            } catch (IOException e) {
                shutdown();
            }
        }

        /**
         * This method writes out the message string to the clients data output
         * stream.
         *
         * @param message the string to be sent to clients.
         *
         */
        public void sendMessage(String message) {
            try {
                out.writeUTF(message);
            } catch (IOException e) {

            }

        }
        
        /**
         * This method writes out a string containing group members
         *
         * @param group the string containing group members separated with a
         * '-' delimiter.
         */
        public void sendGroup(String group) {
            try {
                out.writeUTF("%group:"+group);
            } catch (IOException e) {

            }
        }
        
        /**
         * This method writes out a string prefixed with a command
         * indicating that the message being sent is a group message.
         *
         * @param msg the message being sent to group members
         */
        public void sendGroupMsg(String msg) {
            try {
                out.writeUTF("%groupMsg:"+msg);
            } catch (IOException e) {

            }
        }

        /**
         * This method writes out a string prefixed with a command, which
         * is given from other methods, making it a signal to the client 
         * to perform a specific operation.
         *
         * @param signal the string containing the signal command and 
         * other appended strings
         */
        public void sendSignal(String signal) {
            try {
                out.writeUTF(signal);
            } catch (IOException e) {

            }
        }
        
        /**
         * This method writes out a string which is a signal to all users
         * to update their stored string value of a user's username who has
         * changed their username.
         *
         * @param update the string containing the update-username signal-
         * command as well as the original username, new username and
         * all clients who are connected
         */
        public void changeUsername(String update){
            try {
                out.writeUTF(update);
            } catch (IOException e) {

            }
        }

        /**
         * This method functions the same as the sendMessage method. The only
         * difference is that a string gets appended to the output string which
         * indicates to the recipient client that the message was send
         * privately.
         *
         * @param whisper the string to be sent to the specified client.
         * @param sender the user who sent the whisper message.
         *
         */
        public void whisperMessage(String whisper, String sender) {
            try {
                out.writeUTF(sender + " (whisper): " + whisper);
            } catch (IOException e) {

            }

        }
        
        /**
         * This method closes all data streams of the client and closes the
         * clients socket.
         */
        public void shutdown() {
            try {
                in.close();
                out.close();
                if (!client.isClosed()) {
                    client.close();
                }
            } catch (IOException e) {

            }
        }

    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JList<String> onlineUsersList;
    private javax.swing.JTextArea userActivityTextArea;
    // End of variables declaration//GEN-END:variables
}
